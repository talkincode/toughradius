package adminapi

import (
	"encoding/json"
	"net/http"
	"net/http/httptest"
	"strings"
	"testing"
	"time"

	"github.com/golang-jwt/jwt/v5"
	"github.com/labstack/echo/v4"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"github.com/talkincode/toughradius/v9/config"
	"github.com/talkincode/toughradius/v9/internal/app"
	"github.com/talkincode/toughradius/v9/internal/domain"
	"github.com/talkincode/toughradius/v9/pkg/common"
	"gorm.io/driver/sqlite"
	"gorm.io/gorm"
)

const testJWTSecret = "test-secret-key-for-jwt"

// setupAuthTestDB creates the test data database
func setupAuthTestDB(t *testing.T) *gorm.DB {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	require.NoError(t, err)

	// Automatically migrate the operator table
	err = db.AutoMigrate(&domain.SysOpr{})
	require.NoError(t, err)

	return db
}

// setupAuthTestApp initializes the test application
func setupAuthTestApp(t *testing.T, db *gorm.DB) {
	cfg := &config.AppConfig{
		System: config.SysConfig{
			Appid:    "TestApp",
			Location: "Asia/Shanghai",
			Workdir:  "/tmp/test",
			Debug:    true,
		},
		Web: config.WebConfig{
			Secret: "test-secret-key-for-jwt",
		},
	}
	testApp := app.NewApplication(cfg)
	app.SetGApp(testApp)
	app.SetGDB(db)
}

// setupAuthTest sets up the test environment and creates a test user
func setupAuthTest(t *testing.T) (*domain.SysOpr, func()) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	// Create the test user
	testOpr := &domain.SysOpr{
		ID:        common.UUIDint64(),
		Username:  "testuser",
		Password:  common.Sha256HashWithSalt("password123", common.SecretSalt),
		Realname:  "Test User",
		Email:     "test@example.com",
		Mobile:    "13800138000",
		Level:     "super",
		Status:    common.ENABLED,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	db.Create(testOpr)

	cleanup := func() {
		db.Where("id = ?", testOpr.ID).Delete(&domain.SysOpr{})
	}

	return testOpr, cleanup
}

// TestLoginHandler tests the login handler
func TestLoginHandler(t *testing.T) {
	_, cleanup := setupAuthTest(t)
	defer cleanup()

	tests := []struct {
		name           string
		requestBody    string
		expectedStatus int
		expectedCode   string
		checkToken     bool
	}{
		{
			name:           "Successful login",
			requestBody:    `{"username":"testuser","password":"password123"}`,
			expectedStatus: http.StatusOK,
			expectedCode:   "",
			checkToken:     true,
		},
		{
			name:           "Invalid JSON",
			requestBody:    `{invalid json}`,
			expectedStatus: http.StatusBadRequest,
			expectedCode:   "INVALID_REQUEST",
			checkToken:     false,
		},
		{
			name:           "Empty username",
			requestBody:    `{"username":"","password":"password123"}`,
			expectedStatus: http.StatusBadRequest,
			expectedCode:   "INVALID_CREDENTIALS",
			checkToken:     false,
		},
		{
			name:           "Empty password",
			requestBody:    `{"username":"testuser","password":""}`,
			expectedStatus: http.StatusBadRequest,
			expectedCode:   "INVALID_CREDENTIALS",
			checkToken:     false,
		},
		{
			name:           "User not found",
			requestBody:    `{"username":"nonexistent","password":"password123"}`,
			expectedStatus: http.StatusUnauthorized,
			expectedCode:   "INVALID_CREDENTIALS",
			checkToken:     false,
		},
		{
			name:           "Wrong password",
			requestBody:    `{"username":"testuser","password":"wrongpassword"}`,
			expectedStatus: http.StatusUnauthorized,
			expectedCode:   "INVALID_CREDENTIALS",
			checkToken:     false,
		},
		{
			name:           "Username with surrounding spaces (should be trimmed)",
			requestBody:    `{"username":"  testuser  ","password":"password123"}`,
			expectedStatus: http.StatusOK,
			expectedCode:   "",
			checkToken:     true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			e := echo.New()
			req := httptest.NewRequest(http.MethodPost, "/auth/login", strings.NewReader(tt.requestBody))
			req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
			rec := httptest.NewRecorder()
			c := e.NewContext(req, rec)

			err := loginHandler(c)

			// fail() calls c.JSON() and returns nil, so we check the response code instead of the error
			if tt.expectedStatus >= 400 {
				// Error cases: verify response status and error message
				require.NoError(t, err, "handler should not return error, but write error response")
				assert.Equal(t, tt.expectedStatus, rec.Code)

				var errorResp ErrorResponse
				err = json.Unmarshal(rec.Body.Bytes(), &errorResp)
				require.NoError(t, err)
				assert.Equal(t, tt.expectedCode, errorResp.Error)
			} else {
				assert.NoError(t, err)
				assert.Equal(t, tt.expectedStatus, rec.Code)

				if tt.checkToken {
					var response map[string]interface{}
					err := json.Unmarshal(rec.Body.Bytes(), &response)
					assert.NoError(t, err)

					data, ok := response["data"].(map[string]interface{})
					assert.True(t, ok, "response should have data field")

					// Check token
					token, ok := data["token"].(string)
					assert.True(t, ok, "data should have token field")
					assert.NotEmpty(t, token, "token should not be empty")

					// Check user
					user, ok := data["user"].(map[string]interface{})
					assert.True(t, ok, "data should have user field")
					assert.Equal(t, "testuser", user["username"])
					assert.Empty(t, user["password"], "password should be empty in response")

					// Check tokenExpires
					tokenExpires, ok := data["tokenExpires"].(float64)
					assert.True(t, ok, "data should have tokenExpires field")
					assert.Greater(t, tokenExpires, float64(time.Now().Unix()))
				}
			}
		})
	}
}

// TestLoginHandler_DisabledAccount tests login for a disabled account
func TestLoginHandler_DisabledAccount(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	// Create a disabled test user
	disabledOpr := &domain.SysOpr{
		ID:        common.UUIDint64(),
		Username:  "disableduser",
		Password:  common.Sha256HashWithSalt("password123", common.SecretSalt),
		Realname:  "Disabled User",
		Email:     "disabled@example.com",
		Level:     "operator",
		Status:    common.DISABLED,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	db.Create(disabledOpr)
	defer db.Where("id = ?", disabledOpr.ID).Delete(&domain.SysOpr{})

	e := echo.New()
	req := httptest.NewRequest(http.MethodPost, "/auth/login",
		strings.NewReader(`{"username":"disableduser","password":"password123"}`))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	err := loginHandler(c)

	require.NoError(t, err)
	assert.Equal(t, http.StatusForbidden, rec.Code)

	var errorResp ErrorResponse
	err = json.Unmarshal(rec.Body.Bytes(), &errorResp)
	require.NoError(t, err)
	assert.Equal(t, "ACCOUNT_DISABLED", errorResp.Error)
}

// TestIssueToken tests JWT token generation
func TestIssueToken(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	testOpr := domain.SysOpr{
		ID:       12345,
		Username: "testuser",
		Level:    "super",
	}

	token, err := issueToken(testOpr)
	assert.NoError(t, err)
	assert.NotEmpty(t, token)

	// Parse the token and validate its contents
	parsedToken, err := jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {
		return []byte(testJWTSecret), nil
	})
	assert.NoError(t, err)
	assert.True(t, parsedToken.Valid)

	claims, ok := parsedToken.Claims.(jwt.MapClaims)
	assert.True(t, ok)

	// Validate claims
	assert.Equal(t, "12345", claims["sub"])
	assert.Equal(t, "testuser", claims["username"])
	assert.Equal(t, "super", claims["role"])
	assert.Equal(t, "toughradius", claims["iss"])

	// Validate the time-related fields
	exp, ok := claims["exp"].(float64)
	assert.True(t, ok)
	assert.Greater(t, exp, float64(time.Now().Unix()))

	iat, ok := claims["iat"].(float64)
	assert.True(t, ok)
	assert.LessOrEqual(t, iat, float64(time.Now().Unix()))
}

// TestCurrentUserHandler tests fetching current user info
func TestCurrentUserHandler(t *testing.T) {
	testOpr, cleanup := setupAuthTest(t)
	defer cleanup()

	// Generate a valid token
	token, err := issueToken(*testOpr)
	assert.NoError(t, err)

	// Parse token
	parsedToken, err := jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {
		return []byte(testJWTSecret), nil
	})
	assert.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/auth/me", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	// Simulate the context that the JWT middleware sets
	c.Set("user", parsedToken)

	err = currentUserHandler(c)
	assert.NoError(t, err)
	assert.Equal(t, http.StatusOK, rec.Code)

	var response map[string]interface{}
	err = json.Unmarshal(rec.Body.Bytes(), &response)
	assert.NoError(t, err)

	data, ok := response["data"].(map[string]interface{})
	assert.True(t, ok)

	user, ok := data["user"].(map[string]interface{})
	assert.True(t, ok)
	assert.Equal(t, "testuser", user["username"])
	assert.Empty(t, user["password"], "password should be empty")
}

// TestCurrentUserHandler_NoToken tests the no-token scenario
func TestCurrentUserHandler_NoToken(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/auth/me", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	// Leave the user context unset

	err := currentUserHandler(c)
	require.NoError(t, err)
	assert.Equal(t, http.StatusUnauthorized, rec.Code)

	var errorResp ErrorResponse
	err = json.Unmarshal(rec.Body.Bytes(), &errorResp)
	require.NoError(t, err)
	assert.Equal(t, "UNAUTHORIZED", errorResp.Error)
}

// TestResolveOperatorFromContext tests parsing the operator from context
func TestResolveOperatorFromContext(t *testing.T) {
	testOpr, cleanup := setupAuthTest(t)
	defer cleanup()

	// Generate a valid token
	token, err := issueToken(*testOpr)
	assert.NoError(t, err)

	// Parse token
	parsedToken, err := jwt.Parse(token, func(t *jwt.Token) (interface{}, error) {
		return []byte(testJWTSecret), nil
	})
	assert.NoError(t, err)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user", parsedToken)

	operator, err := resolveOperatorFromContext(c)
	assert.NoError(t, err)
	assert.NotNil(t, operator)
	assert.Equal(t, testOpr.ID, operator.ID)
	assert.Equal(t, testOpr.Username, operator.Username)
	assert.Empty(t, operator.Password, "password should be empty")
}

// TestResolveOperatorFromContext_NoUser tests when no user context exists
func TestResolveOperatorFromContext_NoUser(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	operator, err := resolveOperatorFromContext(c)
	assert.Error(t, err)
	assert.Nil(t, operator)
	assert.Contains(t, err.Error(), "no user in context")
}

// TestResolveOperatorFromContext_InvalidTokenType tests invalid token types
func TestResolveOperatorFromContext_InvalidTokenType(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user", "not a token") // Set an incorrect type

	operator, err := resolveOperatorFromContext(c)
	assert.Error(t, err)
	assert.Nil(t, operator)
	assert.Contains(t, err.Error(), "invalid token type")
}

// TestResolveOperatorFromContext_InvalidClaims tests invalid claims
func TestResolveOperatorFromContext_InvalidClaims(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	// Create a token without a sub claim
	now := time.Now()
	claims := jwt.MapClaims{
		"username": "testuser",
		"exp":      now.Add(tokenTTL).Unix(),
		"iat":      now.Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user", token)

	operator, err := resolveOperatorFromContext(c)
	assert.Error(t, err)
	assert.Nil(t, operator)
	assert.Contains(t, err.Error(), "invalid token subject")
}

// TestResolveOperatorFromContext_UserNotFound tests when the user does not exist
func TestResolveOperatorFromContext_UserNotFound(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	// Create a token referencing a non-existent user
	now := time.Now()
	claims := jwt.MapClaims{
		"sub":      "999999999", // ID of a non-existent user
		"username": "nonexistent",
		"role":     "operator",
		"exp":      now.Add(tokenTTL).Unix(),
		"iat":      now.Unix(),
		"iss":      "toughradius",
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user", token)

	operator, err := resolveOperatorFromContext(c)
	assert.Error(t, err)
	assert.Nil(t, operator)
}

// TestResolveOperatorFromContext_InvalidSubFormat tests invalid sub format
func TestResolveOperatorFromContext_InvalidSubFormat(t *testing.T) {
	db := setupAuthTestDB(t)
	setupAuthTestApp(t, db)

	// Create a token whose sub value is not digits
	now := time.Now()
	claims := jwt.MapClaims{
		"sub":      "not-a-number",
		"username": "testuser",
		"exp":      now.Add(tokenTTL).Unix(),
		"iat":      now.Unix(),
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)

	e := echo.New()
	req := httptest.NewRequest(http.MethodGet, "/", nil)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)
	c.Set("user", token)

	operator, err := resolveOperatorFromContext(c)
	assert.Error(t, err)
	assert.Nil(t, operator)
	assert.Contains(t, err.Error(), "invalid token id")
}

// TestLoginHandler_LastLoginUpdate tests updating last login time after successful login
func TestLoginHandler_LastLoginUpdate(t *testing.T) {
	testOpr, cleanup := setupAuthTest(t)
	defer cleanup()

	// Record the time before login
	beforeLogin := time.Now()

	e := echo.New()
	req := httptest.NewRequest(http.MethodPost, "/auth/login",
		strings.NewReader(`{"username":"testuser","password":"password123"}`))
	req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
	rec := httptest.NewRecorder()
	c := e.NewContext(req, rec)

	err := loginHandler(c)
	assert.NoError(t, err)

	// Wait for the goroutine to finish updating
	time.Sleep(100 * time.Millisecond)

	// Query the user again to check last_login
	var updatedOpr domain.SysOpr
	db.Where("id = ?", testOpr.ID).First(&updatedOpr)

	// last_login should be after the login
	assert.True(t, updatedOpr.LastLogin.After(beforeLogin) || updatedOpr.LastLogin.Equal(beforeLogin))
}

// TestTokenTTL Test token Expiration time
func TestTokenTTL(t *testing.T) {
	assert.Equal(t, 12*time.Hour, tokenTTL, "token TTL should be 12 hours")
}

// BenchmarkLoginHandler benchmarks the login handler
func BenchmarkLoginHandler(b *testing.B) {
	db, err := gorm.Open(sqlite.Open(":memory:"), &gorm.Config{})
	if err != nil {
		b.Fatal(err)
	}

	if err := db.AutoMigrate(&domain.SysOpr{}); err != nil {
		b.Fatal(err)
	}

	cfg := &config.AppConfig{
		System: config.SysConfig{
			Appid:    "TestApp",
			Location: "Asia/Shanghai",
			Workdir:  "/tmp/test",
			Debug:    false,
		},
		Web: config.WebConfig{
			Secret: "test-secret-key-for-jwt",
		},
	}
	testApp := app.NewApplication(cfg)
	app.SetGApp(testApp)
	app.SetGDB(db)

	testOpr := &domain.SysOpr{
		ID:        common.UUIDint64(),
		Username:  "benchuser",
		Password:  common.Sha256HashWithSalt("password123", common.SecretSalt),
		Realname:  "Bench User",
		Level:     "operator",
		Status:    common.ENABLED,
		CreatedAt: time.Now(),
		UpdatedAt: time.Now(),
	}
	db.Create(testOpr)
	defer db.Where("id = ?", testOpr.ID).Delete(&domain.SysOpr{})

	requestBody := `{"username":"benchuser","password":"password123"}`

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		e := echo.New()
		req := httptest.NewRequest(http.MethodPost, "/auth/login", strings.NewReader(requestBody))
		req.Header.Set(echo.HeaderContentType, echo.MIMEApplicationJSON)
		rec := httptest.NewRecorder()
		c := e.NewContext(req, rec)

		_ = loginHandler(c)
	}
}

// BenchmarkIssueToken benchmarks token generation
func BenchmarkIssueToken(b *testing.B) {
	cfg := &config.AppConfig{
		System: config.SysConfig{
			Appid:    "TestApp",
			Location: "Asia/Shanghai",
			Workdir:  "/tmp/test",
			Debug:    false,
		},
		Web: config.WebConfig{
			Secret: "test-secret-key-for-jwt",
		},
	}
	testApp := app.NewApplication(cfg)
	app.SetGApp(testApp)

	testOpr := domain.SysOpr{
		ID:       12345,
		Username: "benchuser",
		Level:    "operator",
	}

	b.ResetTimer()
	for i := 0; i < b.N; i++ {
		_, _ = issueToken(testOpr)
	}
}
